// QoL or coding issues:
1) (In code) Multiple THGEM mappings and single field map implementation is a little bit wonky at the moment: GlobalData behavior (loading field map) is dependent on selected detector type explicitly in the code. Also, when calculating electric field at global point, dummy HexagonalMapping class is created.
2) Proper logging in python scripts (separate log for meshing, field calculations and geant4 simulation as well as python's script itself)
3) .py all testing
4) Create install_all.py for full project set-up: dependency installation, environment set-up and build.
So that [load the code]->[run install_all.py]->[run results/*/RunSimulation.py]->[analyze results] can be done without thinking/remembering what is happening at all. Although CMake does make compilation or Eclipse set-up quite simple at the moment.
5) Fix bug in Garfield++ ComponentElmer::ElectricField(x,y,z,ex,ey,ez,m,status) (most likely in ComponentFieldMap::MapCoordinates or less likely in ComponentFieldMap::FindElement13's conditions) which results in inconsistent fields at the edge of THGEM cell. Ask for pull request as well. UPD: fixed by using optimized mesh. Had to switch to Gmsh v4 for that. 
6) Make python scripts extract THGEM geometry from settings_template.xml into .geo. As of right now .geo geometry must be made the same as in .xml by hand.
7) Add datatable extraction to scripts (e.g. to extract electron energy distribution or NBrS spectrum and specific required field).
8) Configure scripts/print_results_table.cpp for 3 detector configurations which can be selected with only single parameter.
9) Add NBrS yield factor to output files. So that scripts can be aware of it automatically.
10) Add field range configuration to settings
11) Add variable number of events to simulate. It is usually required to simulate certain number of photons (detected or generated), not number of electrons. This is important when working with large ranges of voltages. There is an issue of how to maintain multithreading if condition to stop is certain number of photons.
12) DataVector file header should be made more verbose.
Instead of mystic "//2	1	0	1	1	0	0.0	0"
It should be "//Np=2	Order=1	UseLeftmostVal=0	UseRightmostVal=1	IsSetLeftVal=1	IsSetRightVal=0	LeftSetVal=0.0	RightSetVal=0
or something along those lines.
Better yet, make the header structured: 1. Interpolation/Fitting settings, 2. strategy for x < x_min, 3. strategy for x > x_max.
That way scaling may be potentially suported in the future for outside-bounds x, not only setting y(x) to constant.
Idea for scaling: all derivatives at x_min or x_max should be passed to scaling function.
13) Rewrite post-processing scripts in python.
14) DriftMedium.cc has small error in debug printing. Diffusion coefficents there are in mm^2/ns, not in mm^(1/2).
15) Use faster strtoken implementation (from Documents/Detector_fields/CylinderLAr/CylinderCharge.cpp). In other projects as well.

python3 exact_XS_T11_Tr_Atrazhev_AvgS_Avgmu_B8.9_sh/RunSimulation.py
python3 exact_XS_T11_Tr_Atrazhev_AvgS_Avgmu_McE14_sh/RunSimulation.py
python3 exact_XS_T11_Tr_Var9/RunSimulation.py
python3 exact_XS_T11_Tr_Var10/RunSimulation.py

